# 13장 OAuth 2: 권한 부여 서버 구현

- Spring Authorization Server를 이용하여 OAuth2 및 OpenID Connect 인가 서버를 구축하는 방법을 알아본다.
  ![figure14.1](./fig14_1.png)

## 기본 인가 서버 구현 및 JWT 사용

- JSON 웹 토큰(JWT)을 사용하는 기본적인 OAuth 2 인가 서버를 구현하는 방법부터 시작합니다.
- 주요 구성 성분들
  - configuation filter for protocol endpoints: authorization server관련한 설정한다.
  - authentication configuration filter: authentiation/authorization filter들을 설정한다.
  - user details management component: UserDetailsService, PasswordEncoder 빈들을 통해서 유저 정보들을 관리한다.
  - client details management component: RegisteredClientRepository를 통해서 client 정보를 관리한다.
  - key-pairs management: non-opaque 토큰을 사용할 때 authorization server는 private key를 이용해서 토큰을 서명한다. authorization server는 private key, public key관리를 위해 key source를 제공한다.
  - general app settings: AuthorizationServerSettings를 통해 endpoint와 같은 전반적인 설정을 customize할 수 있게 한다.
    ![figure14.2](./fig14_2.png)
- 프로젝트 세팅

```java
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-authorization-server'
    ...
}
```

- spring oauth2 authorization server 설정 방법

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    // filter chain for the protocol endpoints
    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        // provides the minimal default configuration for an OAuth2 authorization server
        // apply the default configuration and registers a SecurityFilterChain Bean composed of all the infrastructure components supporting an OAuth2 authorization server
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) -> authorizationServer
                        .oidc(Customizer.withDefaults()) // Enable OpenId Connect
                )
                .authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated())
                // Redirect to the Login page when not authenticated from the authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        ));

        return http.build();
    }

    // filter chain for authentication
    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public PasswordEncoder getPasswordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }

    // an instance of UserDetailsService fro retrieving users to authenticate
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails userDetails = User.withUsername("hoseop")
                .password(getPasswordEncoder().encode("1234!"))
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(userDetails);
    }

    // an instance of RegisteredClientRepository for managing clients
    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("oidc-client")
                .clientSecret("{noop}secret")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("http://127.0.0.1:8080/login/oauth2/code/oidc-client")
                .postLogoutRedirectUri("http://127.0.0.1:8080/")
                .scope(OidcScopes.OPENID) // defines a purpose for the request of an access token
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient, credentialClient, credentialClient2);
    }

    // an instance of JWKSource for signing access tokens
    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        }
        catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    // an instance of JwtDecoder for decoding signed access tokens
    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    // an instance of AuthorizationServerSettings to configure Spring Authorization Server
    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().build();
    }
}
```

- client 설정

```java
@Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("oidc-client")
                .clientSecret("{noop}secret")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("http://127.0.0.1:8080/login/oauth2/code/oidc-client")
                .postLogoutRedirectUri("http://127.0.0.1:8080/")
                .scope(OidcScopes.OPENID) // defines a purpose for the request of an access token
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient, credentialClient, credentialClient2);
    }
```

    - withId: 내부적으로 사용하는 고유 ID
    - clientId: 외부적으로 사용할 client 식별 ID
    - clientSecret: client password
    - clientAuthenticatedMethod: client가 access token을 요청할때 인증 방법
    - authorizationGrantType: client가 사용할 grant type. 여러개의 grant type 지정 가능
    - redirectUri: OAuth 2 인가 서버(Authorization Server)가 사용자의 인증 및 동의 과정을 성공적으로 마친 후, 사용자를 다시 돌려보낼 클라이언트 애플리케이션의 특정 주소를 의미
    - scope: access token을 요청하는 목적을 의미

- key 관리 설정

```java
    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        // generating public-private key pair using RSA cryptographic algorithm
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey); // adding the key pair to the set that the authorization server uses to sign the issued tokens
        return new ImmutableJWKSet<>(jwkSet); // wrapping the key set into JWKSource implementation
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        }
        catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }
```

- generic 설정

```java
    // authorization server가 제공하는 모든 endpoint들을 customizaing 할 때 사용
    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().build();
    }
```

## 인가 코드 승인 유형 실행

- 사용자가 직접 로그인해야 하는 '인가 코드 승인 유형(authorization code grant type)'을 실행하고 테스트하는 방법을 보여줍니다

  ### 1. endpoint 체크

  ```bash
  curl --location 'http://localhost:9000/.well-known/oauth-authorization-server' \
  --header 'Cookie: JSESSIONID=A152F8F765372A04CCDBC8B5C6328072'
  ```

  ```bash
  {
  "issuer": "http://localhost:9000",
  "authorization_endpoint": "http://localhost:9000/oauth2/authorize",
  "pushed_authorization_request_endpoint": "http://localhost:9000/oauth2/par",
  "device_authorization_endpoint": "http://localhost:9000/oauth2/device_authorization",
  "token_endpoint": "http://localhost:9000/oauth2/token",
  "token_endpoint_auth_methods_supported": [
      "client_secret_basic",
      "client_secret_post",
      "client_secret_jwt",
      "private_key_jwt",
      "tls_client_auth",
      "self_signed_tls_client_auth"
  ],
  "jwks_uri": "http://localhost:9000/oauth2/jwks",
  "response_types_supported": [
      "code"
  ],
  "grant_types_supported": [
      "authorization_code",
      "client_credentials",
      "refresh_token",
      "urn:ietf:params:oauth:grant-type:device_code",
      "urn:ietf:params:oauth:grant-type:token-exchange"
  ],
  "revocation_endpoint": "http://localhost:9000/oauth2/revoke",
  "revocation_endpoint_auth_methods_supported": [
      "client_secret_basic",
      "client_secret_post",
      "client_secret_jwt",
      "private_key_jwt",
      "tls_client_auth",
      "self_signed_tls_client_auth"
  ],
  "introspection_endpoint": "http://localhost:9000/oauth2/introspect",
  "introspection_endpoint_auth_methods_supported": [
      "client_secret_basic",
      "client_secret_post",
      "client_secret_jwt",
      "private_key_jwt",
      "tls_client_auth",
      "self_signed_tls_client_auth"
  ],
  "code_challenge_methods_supported": [
      "S256"
  ],
  "tls_client_certificate_bound_access_tokens": true,
  "dpop_signing_alg_values_supported": [
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
  ]
  }
  ```

  ### 2. authorization code endpoint

  ```bash
  curl --location --request GET 'http://localhost:9000/oauth2/authorize? \
  response_type=code& \
  client_id=oidc-client& \
  scope=openid& \
  redirect_uri=http%3A%2F%2F127.0.0.1%3A8080%2Flogin%2Foauth2%2Fcode%2Foidc-client& \
  code_challenge=QkYl4awmImPXnT81Fdm6dA-0t2SkUQ1G9ufyNGTlfww& \
  code_challenge_method=S256' \
  --header 'Content-Type: application/json' \
  --header 'Cookie: JSESSIONID=A152F8F765372A04CCDBC8B5C6328072' \
  --data '{
      "username": "hoseop",
      "password": "12345"
  }'
  ```

        - code_challenge: authorization code와 PKCE를 같이 사용싶으면 해당 값을 제공해야한다
        - code_challenge_method: code challenge를 만들때 사용할 hash function을 정의한다

  - PKCE 비활성방법

  ```java
  .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
  ```

  - 위 url를 요청하면 응답값으로 login 페이지로 redirect 된다
    ![figure14.5](./fig14_5.png)
  - 등록된 username과 password로 로그인을하면 url에 authorization code를 돌려준다
    ![figure14.6](./fig14_6.png)

  ### 3. authorization code로 access token 얻기

  ```bash
  curl --location 'http://localhost:9000/oauth2/token' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --header 'Authorization: ••••••' \
    --header 'Cookie: JSESSIONID=3ED30E21D5E0889DAECB98D36B0E1A97' \
    --data-urlencode 'client_id=oidc-client' \
    --data-urlencode 'redirect_uri=http://127.0.0.1:8080/login/oauth2/code/oidc-client' \
    --data-urlencode 'grant_type=authorization_code' \
    --data-urlencode 'code=3Jjf-GMXPvXRiVUo1x6YlxrSZdP1QVIMjuS_zA58yZgiym2zmApERo3FfAGa_D8HluV4jTBXCrVrYCBCP4lq6_xzMhuYJGZ4OXeDzUwZPbAuox6V7LmQ-PxhriPGyc3W' \
    --data-urlencode 'code_verifier=32CHaMNNmuF9VQDpZrvd5w69muQa9OPk5MGzx3aWphA'
  ```

  - Authorization: 설정 시 CLIENT_SECRET_BASIC로 설정했기 때문에 client_id와 secret으로 Basic 인증값을 만들어서 넣는다.

```bash
{
"access_token": "eyJraWQiOiI4ODlhNGFmO…",
"scope": "openid",
"id_token": "eyJraWQiOiI4ODlhNGFmOS1…",
"token_type": "Bearer",
"expires_in": 299
}
```

### 4. code challenge와 code verifier 생성 방법(Java)

```java
SecureRandom secureRandom = new SecureRandom();
byte[] code = new byte[32];
secureRandom.nextBytes(code);
String codeVerifier = Base64.getUrlEncoder() // code verifier 생성
    .withoutPadding()
    .encodeToString(code);

MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
byte[] digested = messageDigest.digest(codeVerifier.getBytes());
String codeChallenge = Base64.getUrlEncoder() // code challenge 생성
    .withoutPadding()
    .encodeToString(digested);
```

## 클라이언트 자격증명 승인 유형 실행

- 사용자 개입 없이 백엔드 서비스와 같은 클라이언트가 직접 액세스 토큰을 요청할 때 사용하는 '클라이언트 자격증명 승인 유형(client credentials grant type)'을 다룹니다.
- client credentials grant type용 client 등록

```java
@Bean
public RegisteredClientRepository registeredClientRepository() {
RegisteredClient credentialClient = RegisteredClient.withId(UUID.randomUUID().toString())
    .clientId("credential-client")
    .clientSecret("{noop}secret2")
    .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
    .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
    .scope("custom") // defines a purpose for the request of an access token
    .build();

    return new InMemoryRegisteredClientRepository(oidcClient, credentialClient,credentialClient2);
}
```

![figure14.7](./fig14_7.png)

- curl을 통한 호출 및 응답값

```bash
curl --location 'http://localhost:9000/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic Y3JlZGVudGlhbC1jbGllbnQ6c2VjcmV0Mg==' \
--header 'Cookie: JSESSIONID=3ED30E21D5E0889DAECB98D36B0E1A97' \
--data-urlencode 'grant_type=client_credentials' \
--data-urlencode 'scope=custom'
```

```bash
{
    "access_token": "eyJraWQiOiJkYjA5OGVmOC1hM2MxLTRhYWYtOWZjNS1kNWY4MTgzMWQ3ZTIiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJjcmVkZW50aWFsLWNsaWVudCIsImF1ZCI6ImNyZWRlbnRpYWwtY2xpZW50IiwibmJmIjoxNzU4NDYyNzU2LCJzY29wZSI6WyJjdXN0b20iXSwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo5MDAwIiwiZXhwIjoxNzU4NDYzMDU2LCJpYXQiOjE3NTg0NjI3NTYsImp0aSI6IjI4Y2Y4NWIzLWQzNTItNDc4My1iZGQ0LTU0M2Y5ZTBmYTkyZCJ9.S8R93caXlNpq58NreqStifB4b2iHvM2y7jXzijR_pPiavVI3423bAoz_HSjpxwEBGL8BeHIwkLMbqdmJQYmzdDiyZzZp0fl_9Bhx67ef0lC3uruhQcDrDj6TgIG6UoI9-HfKjYyZcdXfuNHHks4-2XQIy3YeSPymyd6lCHink8aoMGvs-GlTLNYEDInM-p0ADVc2heuDazOWSa0wT3Cw0jPBq5jG6gePs6DMJQfA4vu9MeImTOyWZj-ZVtakFk7svM56n3_9eiz11L5UZXACrD4Iv0D-oYX19m252275uoUkeuja1ng_Z_eMQ_T3RmYI83Ff8lhVs0skvtVMkGFS0A",
    "scope": "custom",
    "token_type": "Bearer",
    "expires_in": 300
}
```

## 불투명 토큰과 자기 검사(Introspection) 사용

- 데이터를 포함하지 않는 '불투명 토큰(opaque tokens)'을 발급하도록 인가 서버를 설정하는 방법을 설명합니다
- 리소스 서버는 이 토큰의 유효성을 검사하고 상세 정보를 얻기 위해 인가 서버가 제공하는 '자기 검사(introspection)' 엔드포인트를 호출해야 합니다
- opaque token용 client 등록

```java
@Bean
public RegisteredClientRepository registeredClientRepository() {
    RegisteredClient credentialClient2 = RegisteredClient.withId(UUID.randomUUID().toString())
    .clientId("credential-client2")
    .clientSecret("{noop}secret3")
    .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
    .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
    .tokenSettings(TokenSettings.builder()
    .accessTokenFormat(OAuth2TokenFormat.REFERENCE) // configuring the client to use opaque access tokens
    .build())
    .scope("custom") // defines a purpose for the request of an access token
    .build();

    return new InMemoryRegisteredClientRepository(oidcClient, credentialClient, credentialClient2);
}
```

- curl을 통한 호출 방법

```bash
curl --location 'http://localhost:9000/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic Y3JlZGVudGlhbC1jbGllbnQyOnNlY3JldDM=' \
--header 'Cookie: JSESSIONID=3ED30E21D5E0889DAECB98D36B0E1A97' \
--data-urlencode 'grant_type=client_credentials' \
--data-urlencode 'scope=custom'
```

```bash
{
    "access_token": "b6LyIolf10UfGiMfNt0YpE8bNE1sqzzrHh81OVUR7ORkf_ugYtQw0BCNnwC_W0LKNF6cgUbL3Lj4-qJ7JmAip4vepxFpf_28MXpltFlsfFuaQj1PxXqq8QhlTjfy4mW_",
    "scope": "custom",
    "token_type": "Bearer",
    "expires_in": 1800
}
```

    - 응답값으로 얻은 access token은 opaque token이므로 non-opaque token인 JWT토큰보다 짧고 포멧도 다른것을 알 수 있다.

- Introspection: authorization server로부터 opaque token의 유효셩을 검사하고 상세 정보를 얻는 과정

```bash
curl --location 'http://localhost:9000/oauth2/introspect' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic Y3JlZGVudGlhbC1jbGllbnQyOnNlY3JldDM=' \
--header 'Cookie: JSESSIONID=3ED30E21D5E0889DAECB98D36B0E1A97' \
--data-urlencode 'token=b6LyIolf10UfGiMfNt0YpE8bNE1sqzzrHh81OVUR7ORkf_ugYtQw0BCNnwC_W0LKNF6cgUbL3Lj4-qJ7JmAip4vepxFpf_28MXpltFlsfFuaQj1PxXqq8QhlTjfy4mW_'
```

```bash
{
    "active": true,
    "sub": "credential-client2",
    "aud": [
        "credential-client2"
    ],
    "nbf": 1758463044,
    "scope": "custom",
    "iss": "http://localhost:9000",
    "exp": 1758464844,
    "iat": 1758463044,
    "jti": "d7b0c317-f395-4f90-ab67-4bea3ea4730b",
    "client_id": "credential-client2",
    "token_type": "Bearer"
}
```

    - active: 응답값 중에서 active값을 통해서 opaque token이 유효한지 확인 가능하다
    - opaque token의 기본 active time은 300초이다.

- opaque token active time 변경 방법

```java
@Bean
public RegisteredClientRepository registeredClientRepository() {
    RegisteredClient credentialClient2 = RegisteredClient.withId(UUID.randomUUID().toString())
    .clientId("credential-client2")
    .clientSecret("{noop}secret3")
    .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
    .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
    .tokenSettings(TokenSettings.builder()
        .accessTokenFormat(OAuth2TokenFormat.REFERENCE)
        .accessTokenTimeToLive(Duration.ofMinutes(30)) // setting 30 minutes as the access token time to live
    .build())
    .scope("custom") // defines a purpose for the request of an access token
    .build();

    return new InMemoryRegisteredClientRepository(oidcClient, credentialClient, credentialClient2);
}
```

## 토큰 폐기

- 토큰이 도난당했을 경우와 같이, 만료 시간 전에 토큰을 무효화해야 할 때 사용하는 '토큰 폐기(revocation)' 기능에 대해 설명합니다
- 토큰 무효화 url

```bash
curl --location 'http://localhost:9000/oauth2/revoke' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic Y3JlZGVudGlhbC1jbGllbnQyOnNlY3JldDM=' \
--header 'Cookie: JSESSIONID=A152F8F765372A04CCDBC8B5C6328072' \
--data-urlencode 'token=mN0y2OgbpgcSWfo5Rj6VCxfAfy7EUd3NRiC02NFA97ErsodavJ1B8rATSWebYtRBvS1t-n-dEg37Bn-WCVGyvHfNTjhmUM_HmWDEAnhcq793bPPv_I3qFF8ojWA2bz6a'
```

- 토큰 비활성화 여부 확인 url

```bash
curl --location 'http://localhost:9000/oauth2/introspect' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic Y3JlZGVudGlhbC1jbGllbnQyOnNlY3JldDM=' \
--header 'Cookie: JSESSIONID=3ED30E21D5E0889DAECB98D36B0E1A97' \
--data-urlencode 'token=b6LyIolf10UfGiMfNt0YpE8bNE1sqzzrHh81OVUR7ORkf_ugYtQw0BCNnwC_W0LKNF6cgUbL3Lj4-qJ7JmAip4vepxFpf_28MXpltFlsfFuaQj1PxXqq8QhlTjfy4mW_'
```

- revocation 정책을 사용하면 매 call마다 introspection을 호출해야 한다.
- 이렇게 매번 introspection을 호출하는 작업을 performance적으로 나쁜 영향을 끼친다. 그래서 revocation을 적용할 때 항상 performance 측면을 고려해야 한다.
