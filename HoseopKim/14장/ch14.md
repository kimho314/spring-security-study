# 14장 OAuth 2: 리소스 서버 구현

이 장에서는 OAuth 2 시스템에서 백엔드 애플리케이션, 즉 리소스 서버(resource server)를 보호하는 방법을 다룹니다

## 15.1 JWT 검증 설정하기 (Configuring JWT validation)

- 오늘날 OAuth 2 시스템에서 가장 흔하게 사용되는 JWT(JSON Web Token)를 리소스 서버에서 검증하고 사용하는 방법을 설명합니다. 리소스 서버는 JWT가 신뢰할 수 있는 인증 서버에서 발급되었는지 서명을 검증하고, 토큰 내의 데이터를 사용하여 권한 부여 규칙을 구현해야 합니다.
- 구현 단계는 다음과 같습니다:

  1. 의존성 추가: spring-boot-starter-oauth2-resource-server 의존성을 프로젝트에 추가합니다.

  ```java
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-web'
  ```

  2. 테스트용 엔드포인트 생성: 간단한 /demo 엔드포인트를 만듭니다.

  ```java
    @RestController
    public class DemoController {
        @GetMapping(value = "/demo", produces = "application/json")
        public String demo(Authentication authentication){
            return "demo";
        }
    }
  ```

  3. 인증 설정: 리소스 서버는 인증 서버의 공개 키 세트 URI(jwks_uri)를 사용하여 토큰 서명을 검증합니다. 이 URI는 일반적으로 인증 서버의 .well-known/openid-configuration 엔드포인트에서 확인할 수 있습니다.
     ◦ application.properties 파일에 keySetURI를 설정합니다.

     ```bash
     keySetUri: http://localhost:9000/oauth2/jwks
     ```

     ◦ SecurityFilterChain 빈에서 oauth2ResourceServer() 메서드와 jwt() 커스터마이저를 사용하여 jwkSetUri()에 해당 URI를 지정합니다

     ```java
     @Value(value = "${keySetUri}")
     private String keySetUri;

     @Bean
     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.oauth2ResourceServer(
                c -> c.jwt(j -> j.jwkSetUri(keySetUri)// configuring the public key set URI
                )
        );

        return http.build();
     }
     ```

  4. 권한 부여 규칙 설정: 모든 요청이 인증을 요구하도록 설정합니다 (anyRequest().authenticated())

  ```java
     @Bean
     public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        ...

        http.authorizeHttpRequests(
                c -> c.anyRequest().authenticated()
        );

        return http.build();
     }
  ```

  ```bash
    *authorize code cURL
    curl --location --request GET 'http://localhost:9000/oauth2/authorize?response_type=code&client_id=oidc-client&scope=openid&redirect_uri=http%3A%2F%2F127.0.0.1%3A8080%2Flogin%2Foauth2%2Fcode%2Foidc-client&code_challenge=3bDvakq2CxEWQBn6MJHHYe7N6mG6grleFrVePcQEK10&code_challenge_method=S256' \
    --header 'Content-Type: application/json' \
    --data '{
        "username": "hoseop",
        "password": "12345"
    }'

    *access token cURL
    curl --location 'http://localhost:9000/oauth2/token' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --header 'Authorization: Basic b2lkYy1jbGllbnQ6c2VjcmV0' \
    --data-urlencode 'client_id=oidc-client' \
    --data-urlencode 'redirect_uri=http://127.0.0.1:8080/login/oauth2/code/oidc-client' \
    --data-urlencode 'grant_type=authorization_code' \
    --data-urlencode 'code=NscubXsyPzcHEHzTZtjzZmbDbgx4XB5Dv_EVraY_o9jomm0Ilu5K-ZOCy2OXFPBul7YRuq1MHuZD3qyJFSRBO6IlcIhoP1KZ96DsX9ltEuA2VXZiwSr1LMuk5JGeutzk' \
    --data-urlencode 'code_verifier=6DgQpOTczBaX8yJrpD8Mnrzzlqmm20vT-K1V1z4bSR0'

    *demo cURL
    curl --location 'http://localhost:8080/demo' \
    --header 'type: jwt' \
    --header 'Authorization: Bearer eyJraWQiOiJhMDkyNWFiYS1kZjdlLTQ4M2UtYjYzNy03Yzg4NGU0ZjBkZjEiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJyZXNvdXJjZV9zZXJ2ZXIiLCJhdWQiOiJyZXNvdXJjZV9zZXJ2ZXIiLCJuYmYiOjE3NTg5ODg4NzgsInNjb3BlIjpbIlJFQUQiXSwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo5MDAwIiwiZXhwIjoxNzU4OTg5MTc4LCJwcmlvcml0eSI6IkhJR0giLCJpYXQiOjE3NTg5ODg4NzgsImp0aSI6IjM5ZTVmY2ZkLWU2ZTUtNGRmZS1hNDRjLTUxNDEyZmQ1OTZjYyJ9.OKBE6OqtOIGFe_L-tumFoABPLlD1QewZfUmQyMbrNqL2UTauAUdL0YWEAqvVfWamWcRtdKiphBiemvEbaeuxbA2R1F1c75X0N1IB00l3ouxI2UHpsmt1R4Khl9-CqVz8PUMhTs1CEZ5zAwHcIzMnuCCUAoC5xNsZRjhMK2mvnR_muqMM8dOEjZ-Pl9KsYD5bWS9XV_gRqW8cXuLoLEybhudJrhH8O1c-IRmhKJc0PonMjMCGiBmp5MPlExcY4xmI0tVzivxUqYiEoRxJEQgpIfJGcsbbDghlcl0wBhQhdQ_NMovpviMI4NCp02iW4gQRjLTXIQC0I_oxeRW68PIRWA'
  ```

## 15.2 커스텀 JWT 사용하기 (Using customized JWTs)

- 인증 서버와 리소스 서버 간에 커스텀 데이터(클레임)를 액세스 토큰을 통해 전달해야 하는 경우가 많습니다. 리소스 서버는 이 커스텀 클레임을 사용하여 권한 부여 규칙을 적용할 수 있습니다.
- 인증 서버 측 변경: OAuth2TokenCustomizer 빈을 정의하여 JWT에 "priority"와 같은 커스텀 클레임을 추가할 수 있습니다.

```java
    // generating tokens
    @Bean
    public OAuth2TokenGenerator<?> tokenGenerator() { // 해당 메서드는 구현안 해도 됨
        JwtEncoder jwtEncoder = new NimbusJwtEncoder(jwkSource());
        JwtGenerator jwtGenerator = new JwtGenerator(jwtEncoder);
        jwtGenerator.setJwtCustomizer(jwtCustomizer());
        OAuth2AccessTokenGenerator accessTokenGenerator = new OAuth2AccessTokenGenerator();
        OAuth2RefreshTokenGenerator refreshTokenGenerator = new OAuth2RefreshTokenGenerator();
        return new DelegatingOAuth2TokenGenerator(
            jwtGenerator,
            accessTokenGenerator,
            refreshTokenGenerator
        );
    }

    // add priority claim to jwt token
    @Bean
    public OAuth2TokenCustomizer<JwtEncodingContext> jwtCustomizer() {
        return context -> {
            JwtClaimsSet.Builder claims = context.getClaims();
            claims.claim("priority", "HIGH");
        };
    }
```

- 리소스 서버 측 변경:

  1. 커스텀 인증 객체 생성: JwtAuthenticationToken을 상속하여 "priority" 필드를 갖는 커스텀 인증 객체를 만듭니다.

  ```java
    public class CustomAuthentication extends JwtAuthenticationToken {
    private final String priority;


    public CustomAuthentication(Jwt jwt,
                                Collection<? extends GrantedAuthority> authorities,
                                String priority
    ) {
        super(jwt, authorities);
        this.priority = priority;
    }

    public String getPriority() {
        return priority;
    }
  }
  ```

  2. JWT 인증 변환기(Converter) 생성: Converter<Jwt, CustomAuthentication>를 구현하여 JWT의 커스텀 클레임을 읽어 커스텀 인증 객체로 변환하는 로직을 작성합니다.

  ```java
    @Component
    public class JwtAuthenticationConverter implements Converter<Jwt, CustomAuthentication> {
        @Override
        public CustomAuthentication convert(Jwt source) {
            List<GrantedAuthority> authorities = List.of(() -> "read");
            String priority = String.valueOf(source.getClaims().get("priority")); // getting priority from jwt claims
            return new CustomAuthentication(
                source,
                authorities,
                priority
            );
        }
  }
  ```

  3. 변환기 설정: SecurityFilterChain에서 .jwtAuthenticationConverter(converter)를 사용하여 커스텀 변환기를 등록합니다.

  ```java
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
          http.oauth2ResourceServer(
                  c -> c.jwt(j -> j.jwkSetUri(keySetUri)// configuring the public key set URI
                                  .jwtAuthenticationConverter(converter))
          );

        http.authorizeHttpRequests(
                c -> c.anyRequest().authenticated()
        );

        return http.build();
    }

  ```

  4. 설정 후에는 SecurityContext에서 커스텀 클레임이 포함된 인증 객체를 사용할 수 있습니다. jwt token얻을 후 토큰 내용을 살펴보면 priority 데이터가 추가된 것을 확인할 수 있다.

  ```bash
  *The Base64-decoded body of the customized JWT access token
  {
    "sub": "bill",
    "aud": "client",
    "nbf": 1687263329,
    "scope": [
        "openid"
    ],
    "iss": "http://localhost:8080",
    "exp": 1687263629,
    "priority": "HIGH",
    "iat": 1687263329
  }
  ```

## 15.3 Introspection을 통한 토큰 검증 설정하기 (Configuring token validation through introspection)

- 불투명 토큰(Opaque Token)을 사용하거나 토큰 취소(revocation) 기능을 지원해야 할 때 Introspection(토큰 검사)이 필요합니다. 리소스 서버는 인증 서버의 Introspection 엔드포인트를 호출하여 토큰의 유효성을 확인합니다.
- 인증 서버 설정: 리소스 서버가 Introspection 엔드포인트를 호출하려면, 리소스 서버 자체도 인증 서버에 클라이언트로 등록되어야 합니다. 이를 통해 리소스 서버는 호출 시 사용할 자신의 클라이언트 ID와 시크릿을 갖게 됩니다.

```java
 ...

 RegisteredClient resourceServer = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("resource_server")
                .clientSecret("{noop}resource_server_secret")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
                .scope("READ")
                .build();

        return new InMemoryRegisteredClientRepository(
                ...
                resourceServer
        );
```

- 리소스 서버 설정:

  1. application.properties에 Introspection URI, 리소스 서버의 클라이언트 ID 및 시크릿을 설정합니다.

  ```bash
    introspectionUri: http://localhost:9000/oauth2/introspect
    resourceserver:
      clientID: resource_server
      secret: resource_server_secret
  ```

  2. SecurityFilterChain에서 oauth2ResourceServer()와 opaqueToken() 커스터마이저를 사용합니다.

  3. .introspectionUri()와 .introspectionClientCredentials() 메서드를 사용하여 관련 정보를 설정합니다.

  ```java
    @Value("${resourceserver.clientID}")
    private String resourceServerClientID;
    @Value("${resourceserver.secret}")
    private String resourceServerSecret;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // configuring the credentials the resource server must use to authenticate when calling the authorization server’s introspection URI
        http.oauth2ResourceServer(c -> c.opaqueToken(o -> o.introspectionUri(introspectionUri)
                .introspectionClientCredentials(resourceServerClientID, resourceServerSecret)));

        http.authorizeHttpRequests(
                c -> c.anyRequest().authenticated()
        );

        return http.build();
    }
  ```

  ```bash
    curl --location 'http://localhost:9001/oauth2/token' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --header 'Authorization: Basic Y3JlZGVudGlhbC1jbGllbnQyOnNlY3JldDM=' \
    --data-urlencode 'grant_type=client_credentials' \
    --data-urlencode 'scope=READ'
  ```

  ```bash
    {
        "access_token": "2zLyYA8b6Q54-…",
        "token_type": "Bearer",
        "expires_in": 43199
    }
  ```

  ```bash
    curl 'http://localhost:9000/demo' \
    --header 'Authorization: Bearer 2zLyYA8b6Q54-…'
  ```

## 5.4 멀티테넌트 시스템 구현하기 (Implementing multitenant systems)

리소스 서버가 여러 인증 서버를 신뢰해야 하는 경우(멀티테넌시)와 같은 복잡한 시나리오를 다룹니다.
![figure15.8](./fig15_8.png)
![figure15.9](./fig15_9.png)

- 핵심 컴포넌트: AuthenticationManagerResolver는 들어오는 요청에 따라 어떤 AuthenticationManager를 사용할지 동적으로 결정하는 역할을 합니다.
- 여러 JWT 기반 인증 서버 사용: Spring Security가 제공하는 JwtIssuerAuthenticationManagerResolver를 사용하면 여러 인증 서버의 issuer 주소만 등록하여 간단하게 멀티테넌시를 구현할 수 있습니다.
- 복잡한 시나리오 (JWT + Opaque 토큰 동시 사용):

  - 커스텀 AuthenticationManagerResolver 빈을 직접 구현합니다.
  - 이 로직 내에서 요청 헤더(예: "type") 값을 확인하여 JWT용 AuthenticationManager 또는 Opaque 토큰용 AuthenticationManager를 반환하도록 할 수 있습니다.
  - 각각의 AuthenticationManager는 JwtAuthenticationProvider와 OpaqueTokenAuthenticationProvider를 사용하여 구성됩니다.

  ```java
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // configuring multitenancy
        http.oauth2ResourceServer(
                // Configuring the
                // custom authentication manager resolver
                c -> c.authenticationManagerResolver(
                        authenticationManagerResolver(
                                jwtDecoder(),
                                opaqueTokenIntrospector()
                        )
                )
        );

        http.authorizeHttpRequests(
                c -> c.anyRequest().authenticated()
        );

        return http.build();
    }

    @Bean
    public AuthenticationManagerResolver<HttpServletRequest> authenticationManagerResolver(
            JwtDecoder jwtDecoder,
            OpaqueTokenIntrospector opaqueTokenIntrospector
    ) {
        // Defining an authentication manager for the authorization server managing JWT access tokens
        AuthenticationManager jwtAuth = new ProviderManager(
                new JwtAuthenticationProvider(jwtDecoder)
        );
        // Defining another authentication manager for the authorization server managing opaque tokens
        AuthenticationManager opaqueAuth = new ProviderManager(
                new OpaqueTokenAuthenticationProvider(opaqueTokenIntrospector)
        );

        return (request) -> {
            if ("jwt".equals(request.getHeader("type"))) {
                return jwtAuth;
            }
            else {
                return opaqueAuth;
            }
        };
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        // Configuring the public key set URI for the
        // authentication manager working with the
        // authorization server that manages JWT access tokens
        return NimbusJwtDecoder
                .withJwkSetUri("http://localhost:9000/oauth2/jwks") //
                .build();
    }

    @Bean
    public OpaqueTokenIntrospector opaqueTokenIntrospector() {
        // Configuring the introspection URI and credentials for
        // the authentication manager working with the
        // authorization server that manages opaque tokens
        return SpringOpaqueTokenIntrospector.withIntrospectionUri("http://localhost:9001/oauth2/introspect")
                .clientId("credential-client2")
                .clientSecret("secret3")
                .build();
    }
  ```

  ![figure15.10](./fig15_10.png)
